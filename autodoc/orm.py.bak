import sqlalchemy as sa
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import (
    Integer,
    String,
    Float,
    Boolean,
    Numeric,
    Text,
    Column,
)  # Explicit imports for clarity
from typing import List, Optional
import datetime  # Although no explicit date types were in the SQL, it's common


class Base(DeclarativeBase):
    pass


class Workflow(Base):
    __tablename__ = "Workflow"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    # UNIQUE constraint is handled by primary_key=True implicitly, but explicit unique=True is also valid
    # NOT NULL is handled by primary_key=True
    Name: Mapped[str] = mapped_column(String, nullable=False, unique=True)

    # Relationships (back-populated from other tables)
    sources: Mapped[List["Source"]] = relationship("Source", back_populates="workflow")
    instances: Mapped[List["WorkflowInstance"]] = relationship(
        "WorkflowInstance", back_populates="workflow"
    )
    outcomes: Mapped[List["Outcome"]] = relationship("Outcome", back_populates="workflow")

    def __repr__(self) -> str:
        return f"<Workflow(Id={self.Id}, Name='{self.Name}')>"


class SourceType(Base):
    __tablename__ = "SourceType"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True)
    # NOT NULL and UNIQUE handled by primary_key=True
    Name: Mapped[str] = mapped_column(String, nullable=False)
    # Assuming INTEGER here acts as BOOLEAN (0 or 1)
    IsSlow: Mapped[Optional[bool]] = mapped_column(Boolean, nullable=True)
    IsFile: Mapped[Optional[bool]] = mapped_column(Boolean, nullable=True)
    IsMulti: Mapped[Optional[bool]] = mapped_column(
        Boolean, nullable=True
    )  # Corrected column name casing from SQL

    # Relationships
    sources: Mapped[List["Source"]] = relationship("Source", back_populates="source_type")

    def __repr__(self) -> str:
        return f"<SourceType(Id={self.Id}, Name='{self.Name}')>"


class FileAccessType(Base):
    __tablename__ = "FileAccessType"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    Name: Mapped[str] = mapped_column(String, nullable=False, unique=True)

    # Relationships
    file_accesses: Mapped[List["FileAccess"]] = relationship(
        "FileAccess", back_populates="file_access_type"
    )

    def __repr__(self) -> str:
        return f"<FileAccessType(Id={self.Id}, Name='{self.Name}')>"


class FileAccess(Base):
    __tablename__ = "FileAccess"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    FileAccessTypeId: Mapped[int] = mapped_column(
        sa.ForeignKey("FileAccessType.Id"), nullable=False
    )
    LocalPath: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    RemotePath: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    TopLevel: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    URL: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Username: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Password: Mapped[Optional[str]] = mapped_column(
        String, nullable=True
    )  # Consider using specific Password types in practice

    # Relationships
    file_access_type: Mapped["FileAccessType"] = relationship(
        "FileAccessType", back_populates="file_accesses"
    )
    instances: Mapped[List["FileAccessInstance"]] = relationship(
        "FileAccessInstance", back_populates="file_access"
    )

    def __repr__(self) -> str:
        return f"<FileAccess(Id={self.Id}, FileAccessTypeId={self.FileAccessTypeId})>"


class OutcomeType(Base):
    __tablename__ = "OutcomeType"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True)
    Name: Mapped[str] = mapped_column(String, nullable=False)
    # Assuming INTEGER with DEFAULT 1 acts as BOOLEAN
    IsFile: Mapped[bool] = mapped_column(Boolean, nullable=False, server_default=sa.text("1"))

    # Relationships
    outcomes: Mapped[List["Outcome"]] = relationship("Outcome", back_populates="outcome_type")

    def __repr__(self) -> str:
        return f"<OutcomeType(Id={self.Id}, Name='{self.Name}')>"


class DatabaseMetaSource(Base):
    __tablename__ = "DatabaseMetaSource"

    # Columns
    DatabaseId: Mapped[int] = mapped_column(Integer, primary_key=True)
    Name: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    ConnectionString: Mapped[str] = mapped_column(String, nullable=False)

    # Relationships
    sources: Mapped[List["Source"]] = relationship("Source", back_populates="database_meta_source")

    def __repr__(self) -> str:
        return f"<DatabaseMetaSource(DatabaseId={self.DatabaseId}, Name='{self.Name}')>"


class FileSystem(Base):
    __tablename__ = "FileSystem"  # Note: No apparent relationships to other defined tables

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True)
    WindowsFS: Mapped[str] = mapped_column(String, nullable=False)
    LinuxFS: Mapped[str] = mapped_column(String, nullable=False)

    def __repr__(self) -> str:
        return f"<FileSystem(Id={self.Id}, WindowsFS='{self.WindowsFS}')>"


# --- Tables with dependencies defined above ---


class WorkflowInstance(Base):
    __tablename__ = "WorkflowInstance"

    # Columns
    InstanceId: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    ParentInstanceId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("WorkflowInstance.InstanceId"), nullable=True
    )
    # *** Assumption: WorkflowId should be INTEGER FK despite SQL TEXT definition ***
    WorkflowId: Mapped[Optional[int]] = mapped_column(sa.ForeignKey("Workflow.Id"), nullable=True)
    StartTime: Mapped[Optional[float]] = mapped_column(
        Float, nullable=True
    )  # SQLite REAL maps to Float
    EndTime: Mapped[Optional[str]] = mapped_column(
        String, nullable=True
    )  # Kept as String from TEXT. Consider DateTime if format allows.
    Completed: Mapped[bool] = mapped_column(
        Boolean, nullable=False, server_default=sa.text("0")
    )  # Assuming BOOLEAN
    Data: Mapped[Optional[str]] = mapped_column(
        Text, nullable=True
    )  # Use Text for potentially large text fields
    Step: Mapped[int] = mapped_column(Integer, nullable=False, server_default=sa.text("1"))

    # Relationships
    workflow: Mapped[Optional["Workflow"]] = relationship("Workflow", back_populates="instances")
    # Self-referential relationship for parent/child instances
    parent_instance: Mapped[Optional["WorkflowInstance"]] = relationship(
        "WorkflowInstance",  # Target class (itself)
        back_populates="child_instances",
        remote_side=[
            InstanceId
        ],  # Specifies which column on the 'remote' side (the parent's side) to join on
    )
    child_instances: Mapped[List["WorkflowInstance"]] = relationship(
        "WorkflowInstance",
        back_populates="parent_instance",
        # `foreign_keys` is inferred from ParentInstanceId pointing here
    )

    def __repr__(self) -> str:
        return f"<WorkflowInstance(InstanceId={self.InstanceId}, WorkflowId={self.WorkflowId}, Step={self.Step})>"


class Outcome(Base):
    __tablename__ = "Outcome"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    WorkflowId: Mapped[int] = mapped_column(sa.ForeignKey("Workflow.Id"), nullable=False)
    OutcomeTypeId: Mapped[int] = mapped_column(
        sa.ForeignKey("OutcomeType.Id"), nullable=False
    )  # Mapping NUMERIC to Integer FK
    FileUpload: Mapped[bool] = mapped_column(
        Boolean, nullable=False, server_default=sa.text("0")
    )  # Assuming BOOLEAN
    FilterField: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    FilterValue: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Name: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    ParentOutcomeId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("Outcome.Id"), nullable=True
    )
    DocumentOrder: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    InputFileInstanceId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("FileAccessInstance.Id"), nullable=True
    )
    OutputFileInstanceId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("FileAccessInstance.Id"), nullable=True
    )

    # Relationships
    workflow: Mapped["Workflow"] = relationship("Workflow", back_populates="outcomes")
    outcome_type: Mapped["OutcomeType"] = relationship("OutcomeType", back_populates="outcomes")

    # Self-referential relationship for parent/child outcomes
    parent_outcome: Mapped[Optional["Outcome"]] = relationship(
        "Outcome", back_populates="child_outcomes", remote_side=[Id]
    )
    child_outcomes: Mapped[List["Outcome"]] = relationship(
        "Outcome", back_populates="parent_outcome"
    )

    # Relationships to FileAccessInstance (requires explicit foreign_keys)
    input_file_instance: Mapped[Optional["FileAccessInstance"]] = relationship(
        "FileAccessInstance",
        foreign_keys=[InputFileInstanceId],
        back_populates="input_for_outcomes",  # Needs corresponding relationship on FileAccessInstance
    )
    output_file_instance: Mapped[Optional["FileAccessInstance"]] = relationship(
        "FileAccessInstance",
        foreign_keys=[OutputFileInstanceId],
        back_populates="output_for_outcomes",  # Needs corresponding relationship on FileAccessInstance
    )

    # Relationship for FileAccessInstance referencing this Outcome via its OutcomeId column
    related_file_access_instances: Mapped[List["FileAccessInstance"]] = relationship(
        "FileAccessInstance",
        foreign_keys="FileAccessInstance.OutcomeId",  # String form needed when defined later
        back_populates="outcome",
    )

    def __repr__(self) -> str:
        return f"<Outcome(Id={self.Id}, Name='{self.Name}', WorkflowId={self.WorkflowId})>"


class FileAccessInstance(Base):
    __tablename__ = "FileAccessInstance"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True)
    FileAccessId: Mapped[int] = mapped_column(sa.ForeignKey("FileAccess.Id"), nullable=False)
    OutcomeId: Mapped[Optional[int]] = mapped_column(sa.ForeignKey("Outcome.Id"), nullable=True)
    Location: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Bucket: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    # Relationships
    file_access: Mapped["FileAccess"] = relationship("FileAccess", back_populates="instances")
    outcome: Mapped[Optional["Outcome"]] = relationship(
        "Outcome", foreign_keys=[OutcomeId], back_populates="related_file_access_instances"
    )

    # Relationships corresponding to Outcome's FKs pointing here
    input_for_outcomes: Mapped[List["Outcome"]] = relationship(
        "Outcome",
        foreign_keys="Outcome.InputFileInstanceId",  # String form needed when defined later
        back_populates="input_file_instance",
    )
    output_for_outcomes: Mapped[List["Outcome"]] = relationship(
        "Outcome",
        foreign_keys="Outcome.OutputFileInstanceId",  # String form needed when defined later
        back_populates="output_file_instance",
    )

    # Relationship corresponding to Source's FK pointing here
    related_sources: Mapped[List["Source"]] = relationship(
        "Source",
        foreign_keys="Source.FileAccessInstanceId",  # String form needed when defined later
        back_populates="file_access_instance",
    )

    def __repr__(self) -> str:
        return f"<FileAccessInstance(Id={self.Id}, FileAccessId={self.FileAccessId}, Location='{self.Location}')>"


class Source(Base):
    __tablename__ = "Source"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True)
    WorkflowId: Mapped[int] = mapped_column(sa.ForeignKey("Workflow.Id"), nullable=False)
    TypeId: Mapped[int] = mapped_column(sa.ForeignKey("SourceType.Id"), nullable=False)
    FileAccessInstanceId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("FileAccessInstance.Id"), nullable=True
    )
    ZIndex: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    DatabaseId: Mapped[Optional[int]] = mapped_column(
        sa.ForeignKey("DatabaseMetaSource.DatabaseId"), nullable=True
    )
    SQLText: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    Splitter: Mapped[int] = mapped_column(
        Integer, nullable=False, server_default=sa.text("0")
    )  # Assuming non-nullable based on DEFAULT
    FieldName: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Step: Mapped[int] = mapped_column(Integer, nullable=False, server_default=sa.text("1"))
    KeyField: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    ValueField: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Orientation: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    Name: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    SheetName: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    HeaderRow: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    # Relationships
    workflow: Mapped["Workflow"] = relationship("Workflow", back_populates="sources")
    source_type: Mapped["SourceType"] = relationship("SourceType", back_populates="sources")
    file_access_instance: Mapped[Optional["FileAccessInstance"]] = relationship(
        "FileAccessInstance",
        foreign_keys=[FileAccessInstanceId],  # Explicit FK needed
        back_populates="related_sources",
    )
    database_meta_source: Mapped[Optional["DatabaseMetaSource"]] = relationship(
        "DatabaseMetaSource", back_populates="sources"
    )
    form_fields: Mapped[List["SourceFormField"]] = relationship(
        "SourceFormField", back_populates="source"
    )

    def __repr__(self) -> str:
        return f"<Source(Id={self.Id}, Name='{self.Name}', WorkflowId={self.WorkflowId}, TypeId={self.TypeId})>"


class SourceFormField(Base):
    __tablename__ = "SourceFormField"

    # Columns
    Id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    SourceId: Mapped[int] = mapped_column(sa.ForeignKey("Source.Id"), nullable=False)
    FieldType: Mapped[str] = mapped_column(String, nullable=False)
    FieldName: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    FieldLabel: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    # Relationships
    source: Mapped["Source"] = relationship("Source", back_populates="form_fields")

    def __repr__(self) -> str:
        return f"<SourceFormField(Id={self.Id}, SourceId={self.SourceId}, FieldName='{self.FieldName}')>"


# --- Example Usage (Optional) ---
# Replace 'sqlite:///your_database.db' with your actual database connection string
# engine = sa.create_engine('sqlite:///your_database.db')

# Create tables in the database (if they don't exist)
# Base.metadata.create_all(engine)

# Example query:
# from sqlalchemy.orm import sessionmaker
# Session = sessionmaker(bind=engine)
# session = Session()
# first_workflow = session.query(Workflow).first()
# print(first_workflow)
# session.close()
# --- End Example Usage ---


class VSource(Base):
    """
    SQLAlchemy ORM class mapping to the database view 'vSource'.

    This class should be treated as READ-ONLY in application logic,
    as writing directly to views is often not supported or requires
    specific database triggers (e.g., INSTEAD OF triggers in SQLite).

    The primary key 'SourceId' is assumed to be unique for each row
    returned by the view, derived from the underlying 'Source' table's Id.
    """

    __tablename__ = "vSource"  # The exact name of the database view

    # --- Primary Key ---
    # Mapped from Source.Id. Assumed to be unique within the view results.
    SourceId = Column(Integer, primary_key=True)

    # --- Columns from Source table ---
    WorkflowId = Column(Integer)  # Assuming foreign key to a Workflow table
    SourceName = Column(String)
    SheetName = Column(String)
    HeaderRow = Column(Integer)
    SQLText = Column(Text)  # Using Text for potentially long SQL queries
    DatabaseId = Column(Integer)  # Assuming foreign key to a Database table
    FieldName = Column(String)
    Splitter = Column(String)  # Assuming String, adjust if numeric
    Step = Column(Integer)
    KeyField = Column(String)
    ValueField = Column(String)
    Orientation = Column(String)

    # --- Columns from SourceType table ---
    TypeName = Column(String)
    IsFile = Column(Boolean)
    IsMulti = Column(Boolean)

    # --- Columns from DatabaseMetaSource table ---
    DatabaseName = Column(String)

    # --- Columns from FileAccessInstance table ---
    Location = Column(String)
    Bucket = Column(String)
    FileAccessId = Column(Integer)  # Assuming foreign key to FileAccess table

    # --- Columns from FileAccess table ---
    LocalPath = Column(String)
    RemotePath = Column(String)
    URL = Column(String)
    Username = Column(String)
    Password = Column(String)  # Note: Handle password security appropriately

    # --- Columns from FileAccessType table ---
    FileAccessTypeName = Column(String)

    # Optional: Define that this is not a "real" table that SQLAlchemy
    # should try to create or modify. Useful if using Base.metadata.create_all()
    # although mapping to a view usually implies the schema already exists.
    __table_args__ = {"info": dict(is_view=True)}

    def __repr__(self):
        # Optional: Provide a helpful representation for debugging
        return f"<VSource(SourceId={self.SourceId}, TypeName='{self.TypeName}', SourceName='{self.SourceName}')>"


# --- Example Setup (for context, replace with your actual setup) ---
# from sqlalchemy import create_engine
# from sqlalchemy.orm import sessionmaker
#
# DATABASE_URL = "sqlite:///your_database.db" # Replace with your DB connection string
# engine = create_engine(DATABASE_URL)
# SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
#
# # If you were using Base.metadata.create_all(), it would ignore views
# # Base.metadata.create_all(bind=engine) # Typically not needed for views
#
# # --- Example Query Usage ---
# if __name__ == "__main__":
#     db = SessionLocal()
#     try:
#         print("Fetching first 5 entries from vSource view:")
#         results = db.query(VSource).limit(5).all()
#         for row in results:
#             print(row) # Uses the __repr__ method
#
#         print("\nFetching specific source by ID (e.g., ID 1):")
#         source_1 = db.query(VSource).get(1) # Uses the primary key
#         if source_1:
#             print(f"Source ID 1 Type: {source_1.TypeName}, Name: {source_1.SourceName}")
#         else:
#             print("Source ID 1 not found.")
#
#     finally:
#         db.close()


class VOutcome(Base):
    """
    SQLAlchemy ORM class mapping to the database view 'vOutcome'.

    This class should be treated as READ-ONLY in application logic.
    Writing directly to views requires specific database configurations
    (e.g., INSTEAD OF triggers) that are not handled by this mapping.

    The primary key 'OutcomeId' is assumed to be unique for each row
    returned by the view, derived from the underlying 'Outcome' table's Id.
    Columns derived from the LEFT JOIN to 'vFileAccessInstance' may be NULL.
    """

    __tablename__ = "vOutcome"  # The exact name of the database view

    # --- Primary Key ---
    # Mapped from Outcome.Id. Assumed to be unique within the view results.
    OutcomeId = Column(Integer, primary_key=True)

    # --- Columns from Outcome table ---
    WorkflowId = Column(Integer)  # Assuming foreign key to a Workflow table
    FilterField = Column(String)
    FilterValue = Column(String)
    ParentOutcomeId = Column(Integer, nullable=True)  # Can be null if no parent
    DocumentOrder = Column(Integer)  # Assuming integer order
    OutcomeName = Column(String)
    InputFileInstanceId = Column(Integer, nullable=True)  # FK, potentially null via LEFT JOIN
    OutputFileInstanceId = Column(Integer, nullable=True)  # FK, potentially null via LEFT JOIN

    # --- Columns from OutcomeType table ---
    OutcomeTypeName = Column(String)
    IsFile = Column(Boolean)

    # --- Columns from InputFileAccessInstance (vFileAccessInstance alias) ---
    # These columns can be NULL because of the LEFT JOIN
    InputFileLocation = Column(String, nullable=True)
    InputFileBucket = Column(String, nullable=True)
    InputLocalPath = Column(String, nullable=True)
    InputRemotePath = Column(String, nullable=True)
    InputURL = Column(String, nullable=True)
    InputFileTypeName = Column(String, nullable=True)  # Mapped from vFileAccessInstance.Name
    InputUserName = Column(String, nullable=True)
    InputPassword = Column(String, nullable=True)  # Note: Handle password security appropriately

    # --- Columns from OutputFileAccessInstance (vFileAccessInstance alias) ---
    # These columns can also be NULL because of the LEFT JOIN
    OutputFileLocation = Column(String, nullable=True)
    OutputFileBucket = Column(String, nullable=True)
    OutputLocalPath = Column(String, nullable=True)
    OutputRemotePath = Column(String, nullable=True)
    OutputURL = Column(String, nullable=True)
    OutputFileTypeName = Column(String, nullable=True)  # Mapped from vFileAccessInstance.Name
    OutputUserName = Column(String, nullable=True)
    OutputPassword = Column(String, nullable=True)  # Note: Handle password security appropriately

    # Optional: Define that this is not a "real" table that SQLAlchemy
    # should try to create or modify.
    __table_args__ = {"info": dict(is_view=True)}

    def __repr__(self):
        # Optional: Provide a helpful representation for debugging
        return (
            f"<VOutcome(OutcomeId={self.OutcomeId}, "
            f"OutcomeTypeName='{self.OutcomeTypeName}', "
            f"OutcomeName='{self.OutcomeName}')>"
        )
